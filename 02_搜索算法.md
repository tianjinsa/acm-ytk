# 搜索算法

## 深度优先搜索

### 算法设计思路

【深度优先搜索(DFS)】是一种用于遍历或搜索树或图的算法。它沿着树的深度遍历节点，尽可能深地搜索树的分支。DFS可以用递归或栈实现。

### 代码实现与逻辑拆解

**递归实现**：

```cpp
void dfs(vector<vector<int>>& graph, int node, vector<bool>& visited) {
    visited[node] = true;  // 标记当前节点为已访问
    
    // 处理当前节点
    cout << node << " ";
    
    // 递归访问所有未访问的相邻节点
    for (int neighbor : graph[node]) {
        if (!visited[neighbor]) {
            dfs(graph, neighbor, visited);
        }
    }
}
```

**非递归实现**：

```cpp
void dfsIterative(vector<vector<int>>& graph, int start) {
    vector<bool> visited(graph.size(), false);
    stack<int> s;
    
    s.push(start);
    
    while (!s.empty()) {
        int node = s.top();
        s.pop();
        
        if (!visited[node]) {
            visited[node] = true;
            cout << node << " ";  // 处理当前节点
            
            // 将所有未访问的相邻节点入栈
            for (int neighbor : graph[node]) {
                if (!visited[neighbor]) {
                    s.push(neighbor);
                }
            }
        }
    }
}
```

### 关键语法特性解析

1. **递归**：DFS的递归实现利用系统栈来保存状态
2. **栈**：非递归实现使用显式栈来模拟递归过程
3. **节点标记**：使用visited数组避免重复访问
4. **STL容器**：使用`vector`存储图的邻接表，`stack`实现非递归DFS

### 复杂度分析

- **时间复杂度**：O(V + E)，V是顶点数，E是边数
  - 每个顶点和每条边最多被访问一次

- **空间复杂度**：O(V)，递归栈或显式栈的空间

### 应用实例

**例题：岛屿数量**

给定一个由'1'（陆地）和'0'（水）组成的二维网格，计算网格中岛屿的数量。

```cpp
int numIslands(vector<vector<char>>& grid) {
    if (grid.empty()) return 0;
    
    int rows = grid.size();
    int cols = grid[0].size();
    int count = 0;
    
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            if (grid[i][j] == '1') {
                count++;              // 发现新的岛屿
                dfs(grid, i, j);      // 使用DFS将整个岛屿标记为已访问
            }
        }
    }
    
    return count;
}

// DFS遍历岛屿的所有部分，并标记为已访问
void dfs(vector<vector<char>>& grid, int i, int j) {
    int rows = grid.size();
    int cols = grid[0].size();
    
    // 边界检查和已访问检查
    if (i < 0 || j < 0 || i >= rows || j >= cols || grid[i][j] != '1') {
        return;
    }
    
    grid[i][j] = '0';  // 标记为已访问（直接修改为水）
    
    // 向四个方向扩展
    dfs(grid, i + 1, j);  // 下
    dfs(grid, i - 1, j);  // 上
    dfs(grid, i, j + 1);  // 右
    dfs(grid, i, j - 1);  // 左
}
```

### 易错点与调试技巧

1. **栈溢出**：在深度很大的图中，递归DFS可能导致栈溢出，考虑使用非递归实现
2. **访问标记**：忘记标记已访问节点会导致无限递归
3. **边界检查**：在网格问题中，需要仔细检查索引是否越界
4. **调试技巧**：
   - 打印访问顺序，验证搜索路径
   - 对于小规模问题，手动追踪递归调用栈
   - 使用断点调试复杂的DFS逻辑

## 广度优先搜索

### 算法设计思路

【广度优先搜索(BFS)】是一种图或树的遍历算法，它从指定的根节点开始，先访问根节点的所有相邻节点，然后再按照同样的顺序访问这些相邻节点的相邻节点，依此类推。

BFS的核心思想是**逐层遍历**，它通常用于：
- 寻找最短路径（无权图）
- 层序遍历
- 连通区域分析
- 最小操作次数问题

### 代码实现与逻辑拆解

**基于队列的BFS实现**：

```cpp
void bfs(vector<vector<int>>& graph, int start) {
    int n = graph.size();
    vector<bool> visited(n, false);
    queue<int> q;
    
    visited[start] = true;  // 标记起始节点为已访问
    q.push(start);          // 将起始节点入队
    
    while (!q.empty()) {
        int node = q.front();
        q.pop();
        
        cout << node << " ";  // 处理当前节点
        
        // 访问所有未访问的相邻节点
        for (int neighbor : graph[node]) {
            if (!visited[neighbor]) {
                visited[neighbor] = true;  // 标记为已访问
                q.push(neighbor);          // 将相邻节点加入队列
            }
        }
    }
}
```

**带层数的BFS实现**（常用于最短路径问题）：

```cpp
void bfsWithLevel(vector<vector<int>>& graph, int start) {
    int n = graph.size();
    vector<bool> visited(n, false);
    vector<int> distance(n, -1);  // 存储从起点到每个节点的距离
    queue<int> q;
    
    visited[start] = true;
    distance[start] = 0;
    q.push(start);
    
    while (!q.empty()) {
        int node = q.front();
        q.pop();
        
        cout << "Node " << node << ", Distance: " << distance[node] << endl;
        
        for (int neighbor : graph[node]) {
            if (!visited[neighbor]) {
                visited[neighbor] = true;
                distance[neighbor] = distance[node] + 1;  // 更新距离
                q.push(neighbor);
            }
        }
    }
}
```

### 关键语法特性解析

1. **队列数据结构**：BFS使用队列（FIFO）来管理待访问节点
2. **节点标记**：使用visited数组避免重复访问
3. **层次信息**：可以通过额外的distance数组或队列大小追踪层次信息
4. **STL队列**：使用C++标准库的`queue<T>`数据结构，主要操作有：
   - `push()`：将元素添加到队尾
   - `pop()`：移除队首元素
   - `front()`：访问队首元素
   - `empty()`：检查队列是否为空

### 复杂度分析

- **时间复杂度**：O(V + E)，V是顶点数，E是边数
  - 每个顶点和每条边最多被访问一次

- **空间复杂度**：O(V)，队列中最多存储V个顶点

### 应用实例

**例题：迷宫中的最短路径**

给定一个二维矩阵表示迷宫，1表示墙壁，0表示可通过的路径。从起点(0,0)到终点(n-1,m-1)的最短路径长度是多少？如果无法到达，返回-1。

```cpp
int shortestPathBFS(vector<vector<int>>& maze) {
    if (maze.empty() || maze[0].empty()) return -1;
    if (maze[0][0] == 1) return -1;  // 起点是墙
    
    int rows = maze.size();
    int cols = maze[0].size();
    
    // 定义上下左右四个方向
    vector<pair<int, int>> dirs = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
    
    // BFS队列
    queue<pair<int, int>> q;
    q.push({0, 0});
    
    // 标记已访问的位置
    vector<vector<bool>> visited(rows, vector<bool>(cols, false));
    visited[0][0] = true;
    
    // 记录步数
    int steps = 0;
    
    while (!q.empty()) {
        int size = q.size();  // 当前层的节点数
        
        for (int i = 0; i < size; i++) {
            auto [x, y] = q.front();
            q.pop();
            
            if (x == rows - 1 && y == cols - 1) {
                return steps;  // 到达终点
            }
            
            // 尝试四个方向
            for (auto& dir : dirs) {
                int nx = x + dir.first;
                int ny = y + dir.second;
                
                // 检查是否有效且未访问
                if (nx >= 0 && nx < rows && ny >= 0 && ny < cols && 
                    maze[nx][ny] == 0 && !visited[nx][ny]) {
                    visited[nx][ny] = true;
                    q.push({nx, ny});
                }
            }
        }
        
        steps++;  // 当前层处理完，步数加1
    }
    
    return -1;  // 无法到达终点
}
```

### 易错点与调试技巧

1. **忘记标记已访问**：BFS中忘记标记已访问节点会导致重复访问和可能的死循环
2. **标记时机**：应当在将节点入队时就标记为已访问，而不是出队时
3. **方向数组**：在网格问题中使用方向数组可以简化代码，但要注意边界检查
4. **调试技巧**：
   - 打印每一层的节点，验证BFS是否真的在"逐层"访问
   - 在复杂问题中，可视化队列和已访问节点的状态

## 二分查找

### 算法设计思路

【二分查找】是一种在**有序数组**中查找特定元素的高效算法。其核心思想是将目标值与数组中间元素比较，根据比较结果将查找范围缩小一半，直到找到目标或确定目标不存在。

二分查找常用于：
- 在有序数组中查找特定值
- 找出满足特定条件的最小/最大值（二分答案）
- 解决各种需要在有序集合上定位元素的问题

### 代码实现与逻辑拆解

**基础二分查找**（查找目标值的索引）：

```cpp
int binarySearch(vector<int>& nums, int target) {
    int left = 0;
    int right = nums.size() - 1;
    
    while (left <= right) {
        int mid = left + (right - left) / 2;  // 避免整数溢出
        
        if (nums[mid] == target) {
            return mid;  // 找到目标
        } else if (nums[mid] < target) {
            left = mid + 1;  // 目标在右半部分
        } else {
            right = mid - 1;  // 目标在左半部分
        }
    }
    
    return -1;  // 目标不存在
}
```

**查找第一个等于目标值的元素**：

```cpp
int findFirstEqual(vector<int>& nums, int target) {
    int left = 0;
    int right = nums.size() - 1;
    int result = -1;
    
    while (left <= right) {
        int mid = left + (right - left) / 2;
        
        if (nums[mid] == target) {
            result = mid;      // 记录当前位置
            right = mid - 1;   // 继续向左查找
        } else if (nums[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    
    return result;
}
```

**查找最后一个等于目标值的元素**：

```cpp
int findLastEqual(vector<int>& nums, int target) {
    int left = 0;
    int right = nums.size() - 1;
    int result = -1;
    
    while (left <= right) {
        int mid = left + (right - left) / 2;
        
        if (nums[mid] == target) {
            result = mid;      // 记录当前位置
            left = mid + 1;    // 继续向右查找
        } else if (nums[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    
    return result;
}
```

**查找第一个大于等于目标值的元素**（下界）：

```cpp
int lowerBound(vector<int>& nums, int target) {
    int left = 0;
    int right = nums.size();  // 注意右边界
    
    while (left < right) {
        int mid = left + (right - left) / 2;
        
        if (nums[mid] >= target) {
            right = mid;  // 收紧右边界
        } else {
            left = mid + 1;
        }
    }
    
    return left;  // 可能等于nums.size()
}
```

**查找第一个大于目标值的元素**（上界）：

```cpp
int upperBound(vector<int>& nums, int target) {
    int left = 0;
    int right = nums.size();
    
    while (left < right) {
        int mid = left + (right - left) / 2;
        
        if (nums[mid] > target) {
            right = mid;
        } else {
            left = mid + 1;
        }
    }
    
    return left;
}
```

### 关键语法特性解析

1. **循环条件**：
   - `left <= right`：用于找特定值
   - `left < right`：用于找边界值

2. **中间索引计算**：`mid = left + (right - left) / 2` 避免整数溢出

3. **边界更新**：
   - 基本二分：`left = mid + 1` 或 `right = mid - 1`
   - 边界二分：`left = mid + 1` 或 `right = mid`

4. **STL中的二分查找**：
   - `lower_bound()`：返回首个不小于给定值的元素迭代器
   - `upper_bound()`：返回首个大于给定值的元素迭代器
   - `binary_search()`：检查元素是否存在

### 复杂度分析

- **时间复杂度**：O(log n)，每次迭代将搜索空间减半
- **空间复杂度**：O(1)，只使用常数额外空间

### 应用实例

**例题：搜索旋转排序数组**

一个升序排列的数组在某个未知点上进行了旋转（例如 [0,1,2,4,5,6,7] 变为 [4,5,6,7,0,1,2]）。在数组中搜索目标值，存在则返回下标，否则返回 -1。

```cpp
int search(vector<int>& nums, int target) {
    int left = 0;
    int right = nums.size() - 1;
    
    while (left <= right) {
        int mid = left + (right - left) / 2;
        
        if (nums[mid] == target) {
            return mid;
        }
        
        // 判断mid在哪个排序子数组中
        if (nums[left] <= nums[mid]) { // 左半部分有序
            if (nums[left] <= target && target < nums[mid]) {
                right = mid - 1; // 目标在左半部分
            } else {
                left = mid + 1;  // 目标在右半部分
            }
        } else { // 右半部分有序
            if (nums[mid] < target && target <= nums[right]) {
                left = mid + 1;  // 目标在右半部分
            } else {
                right = mid - 1; // 目标在左半部分
            }
        }
    }
    
    return -1;
}
```

**二分答案**：求平方根的整数部分

```cpp
int mySqrt(int x) {
    if (x <= 1) return x;
    
    int left = 0;
    int right = x;
    int result = -1;
    
    while (left <= right) {
        int mid = left + (right - left) / 2;
        
        // 使用除法避免溢出
        if ((long long)mid * mid <= x) {
            result = mid;
            left = mid + 1;  // 继续查找可能更大的答案
        } else {
            right = mid - 1;
        }
    }
    
    return result;
}
```

### 易错点与调试技巧

1. **边界条件**：特别是循环条件`left <= right`与`left < right`的选择
2. **死循环**：如果更新边界不当，可能出现死循环
3. **整数溢出**：计算mid时应使用`left + (right - left) / 2`而非`(left + right) / 2`
4. **边界更新**：是否应该包含mid取决于具体问题
5. **调试技巧**：
   - 输出每步的left、mid、right值，观察搜索范围的变化
   - 用手动追踪小规模例子验证逻辑
   - 检查特殊情况：空数组、单元素数组、目标不存在等

## 回溯法

### 算法设计思路

【回溯法】是一种通过**试错**来解决问题的算法。它尝试通过构建候选解决方案，当发现当前路径不可行时，就撤销上一步（回溯）并尝试其他可能性，直到找到一个解决方案或尝试完所有可能性。

回溯法常用于解决：
- 排列组合问题
- 子集问题
- 路径搜索问题
- 棋盘布局问题（如八皇后）
- 约束满足问题（如数独）

回溯法通常使用深度优先搜索(DFS)的框架，但关键在于**做选择**、**递归**和**撤销选择**三个步骤。

### 代码实现与逻辑拆解

**回溯算法的一般框架**：

```cpp
void backtrack(参数) {
    if (终止条件) {
        保存结果;
        return;
    }
    
    for (选择：选择列表) {
        做选择;
        backtrack(参数);
        撤销选择;
    }
}
```

**经典例题：生成所有可能的组合**

给定两个整数n和k，返回范围[1, n]中所有可能的k个数的组合。

```cpp
vector<vector<int>> combine(int n, int k) {
    vector<vector<int>> results;
    vector<int> current;
    
    function<void(int)> backtrack = [&](int start) {
        // 终止条件：找到一个符合要求的组合
        if (current.size() == k) {
            results.push_back(current);
            return;
        }
        
        // 尝试每个可能的数字
        for (int i = start; i <= n; i++) {
            current.push_back(i);       // 做选择
            backtrack(i + 1);           // 递归到下一层
            current.pop_back();         // 撤销选择
        }
    };
    
    backtrack(1);  // 从1开始
    return results;
}
```

**全排列问题**：

```cpp
vector<vector<int>> permute(vector<int>& nums) {
    vector<vector<int>> results;
    vector<int> current;
    vector<bool> used(nums.size(), false);
    
    function<void()> backtrack = [&]() {
        // 终止条件：找到一个排列
        if (current.size() == nums.size()) {
            results.push_back(current);
            return;
        }
        
        for (int i = 0; i < nums.size(); i++) {
            if (used[i]) continue;  // 跳过已使用的元素
            
            current.push_back(nums[i]);  // 做选择
            used[i] = true;              // 标记为已使用
            
            backtrack();                 // 递归
            
            current.pop_back();          // 撤销选择
            used[i] = false;             // 标记为未使用
        }
    };
    
    backtrack();
    return results;
}
```

### 关键语法特性解析

1. **递归**：回溯法通常通过递归实现，每次递归代表尝试一种选择
2. **决策树**：可以将回溯过程视为在决策树上的遍历
3. **状态管理**：维护当前状态（如已选元素、已访问节点等）
4. **剪枝**：通过提前判断跳过无效分支，优化搜索过程
5. **C++11 Lambda表达式**：常用于实现局部递归函数
6. **STL容器操作**：如`vector.push_back()`和`vector.pop_back()`用于添加和回溯选择

### 复杂度分析

回溯算法的时间复杂度通常是指数级的，取决于搜索空间的大小：

- **时间复杂度**：通常为O(n!)或O(2^n)或O(n^k)等
  - 排列问题：O(n!)
  - 子集问题：O(2^n)
  - 组合问题：O(C(n,k))

- **空间复杂度**：O(n)到O(n^2)，取决于递归深度和存储中间结果所需空间

### 应用实例

**例题：N皇后问题**

在N×N的棋盘上放置N个皇后，使得它们互不攻击（同行、同列、同对角线上不能有两个皇后）。

```cpp
vector<vector<string>> solveNQueens(int n) {
    vector<vector<string>> results;
    vector<string> board(n, string(n, '.'));  // 初始化棋盘
    
    function<bool(int, int)> isValid = [&](int row, int col) {
        // 检查列
        for (int i = 0; i < row; i++) {
            if (board[i][col] == 'Q') return false;
        }
        
        // 检查左上对角线
        for (int i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--) {
            if (board[i][j] == 'Q') return false;
        }
        
        // 检查右上对角线
        for (int i = row - 1, j = col + 1; i >= 0 && j < n; i--, j++) {
            if (board[i][j] == 'Q') return false;
        }
        
        return true;
    };
    
    function<void(int)> backtrack = [&](int row) {
        // 终止条件：所有行都放置了皇后
        if (row == n) {
            results.push_back(board);
            return;
        }
        
        for (int col = 0; col < n; col++) {
            if (isValid(row, col)) {
                board[row][col] = 'Q';     // 做选择
                backtrack(row + 1);        // 递归到下一行
                board[row][col] = '.';     // 撤销选择
            }
        }
    };
    
    backtrack(0);  // 从第0行开始
    return results;
}
```

**例题：子集生成**

给定一个不含重复元素的整数数组，返回该数组所有可能的子集。

```cpp
vector<vector<int>> subsets(vector<int>& nums) {
    vector<vector<int>> results;
    vector<int> current;
    
    function<void(int)> backtrack = [&](int start) {
        // 每一个状态都是一个合法的子集
        results.push_back(current);
        
        for (int i = start; i < nums.size(); i++) {
            current.push_back(nums[i]);  // 做选择
            backtrack(i + 1);            // 递归
            current.pop_back();          // 撤销选择
        }
    };
    
    backtrack(0);
    return results;
}
```

### 易错点与调试技巧

1. **无限递归**：忘记更新递归参数或条件错误可能导致无限递归
2. **状态管理**：在递归前后的状态管理必须对应（做选择和撤销选择）
3. **基础情况**：忘记处理递归终止条件
4. **剪枝不当**：过度剪枝可能错过有效解
5. **调试技巧**：
   - 打印递归的每一步，观察状态变化
   - 对于小规模问题，手动跟踪递归树
   - 使用断点在关键位置检查变量状态
   - 检查是否正确回溯状态