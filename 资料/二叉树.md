# 二叉树 (Binary Tree)

## 1. 基本概念

【二叉树】是一种非线性数据结构，每个节点最多有两个子节点，分别称为左子节点和右子节点。

### 1.1 基本术语
- **根节点**：二叉树最顶层的节点
- **叶子节点**：没有子节点的节点
- **内部节点**：有至少一个子节点的节点
- **高度/深度**：从根到最远叶子节点的最长路径上的边数
- **层**：从根开始定义，根为第1层

### 1.2 特殊二叉树类型
- **满二叉树**：除叶子节点外，每个节点都有两个子节点，所有叶子节点都在同一层
- **完全二叉树**：除最后一层外，每层都被完全填充，最后一层的所有节点都尽可能靠左排列
- **平衡二叉树**：任意节点的左右子树高度差不超过1

## 2. 二叉树的实现

### 2.1 节点定义

```cpp
// 二叉树节点的基本结构
struct TreeNode {
    int val;         // 节点存储的值
    TreeNode *left;  // 指向左子节点的指针
    TreeNode *right; // 指向右子节点的指针
    
    // 构造函数
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};
```

### 2.2 二叉树的创建

```cpp
// 创建一个简单的二叉树
TreeNode* createBinaryTree() {
    // 创建根节点
    TreeNode* root = new TreeNode(1);
    
    // 创建第二层节点
    root->left = new TreeNode(2);
    root->right = new TreeNode(3);
    
    // 创建第三层节点
    root->left->left = new TreeNode(4);
    root->left->right = new TreeNode(5);
    root->right->left = new TreeNode(6);
    root->right->right = new TreeNode(7);
    
    return root;
}
```

## 3. 二叉树的遍历

【遍历】是二叉树最基本的操作，常见的遍历方式有前序、中序、后序和层序遍历。

### 3.1 深度优先遍历 (DFS)

#### 3.1.1 前序遍历 (根-左-右)

```cpp
// 递归实现前序遍历
void preOrderTraversal(TreeNode* root) {
    if (root == nullptr) return;
    
    cout << root->val << " ";  // 先访问根节点
    preOrderTraversal(root->left);  // 再遍历左子树
    preOrderTraversal(root->right); // 最后遍历右子树
}

// 非递归实现前序遍历
vector<int> preOrderIterative(TreeNode* root) {
    vector<int> result;
    if (root == nullptr) return result;
    
    stack<TreeNode*> s;
    s.push(root);
    
    while (!s.empty()) {
        TreeNode* node = s.top();
        s.pop();
        result.push_back(node->val);  // 访问根节点
        
        // 注意：栈是LIFO，所以先压入右子节点，再压入左子节点
        if (node->right) s.push(node->right);  // 右子节点后进先出
        if (node->left) s.push(node->left);    // 左子节点后进后出，但会比右子节点先处理
    }
    
    return result;
}
```

#### 3.1.2 中序遍历 (左-根-右)

```cpp
// 递归实现中序遍历
void inOrderTraversal(TreeNode* root) {
    if (root == nullptr) return;
    
    inOrderTraversal(root->left);   // 先遍历左子树
    cout << root->val << " ";       // 再访问根节点
    inOrderTraversal(root->right);  // 最后遍历右子树
}

// 非递归实现中序遍历
vector<int> inOrderIterative(TreeNode* root) {
    vector<int> result;
    if (root == nullptr) return result;
    
    stack<TreeNode*> s;
    TreeNode* current = root;
    
    while (current != nullptr || !s.empty()) {
        // 一直往左走，直到走到最左边
        while (current != nullptr) {
            s.push(current);
            current = current->left;
        }
        
        // 当前节点为空，说明已到达最左端
        current = s.top();
        s.pop();
        result.push_back(current->val);  // 访问节点值
        
        // 转向右子树
        current = current->right;
    }
    
    return result;
}
```

#### 3.1.3 后序遍历 (左-右-根)

```cpp
// 递归实现后序遍历
void postOrderTraversal(TreeNode* root) {
    if (root == nullptr) return;
    
    postOrderTraversal(root->left);   // 先遍历左子树
    postOrderTraversal(root->right);  // 再遍历右子树
    cout << root->val << " ";         // 最后访问根节点
}

// 非递归实现后序遍历
vector<int> postOrderIterative(TreeNode* root) {
    vector<int> result;
    if (root == nullptr) return result;
    
    stack<TreeNode*> s1, s2;
    s1.push(root);
    
    // 利用两个栈实现
    while (!s1.empty()) {
        TreeNode* node = s1.top();
        s1.pop();
        s2.push(node);  // s2栈顶到栈底顺序就是后序遍历结果
        
        if (node->left) s1.push(node->left);
        if (node->right) s1.push(node->right);
    }
    
    // 从s2中取出元素，即为后序遍历结果
    while (!s2.empty()) {
        result.push_back(s2.top()->val);
        s2.pop();
    }
    
    return result;
}
```

### 3.2 广度优先遍历 (BFS)

#### 3.2.1 层序遍历

```cpp
// 实现层序遍历
vector<vector<int>> levelOrderTraversal(TreeNode* root) {
    vector<vector<int>> result;
    if (root == nullptr) return result;
    
    queue<TreeNode*> q;
    q.push(root);
    
    while (!q.empty()) {
        int levelSize = q.size();  // 当前层的节点数
        vector<int> currentLevel;
        
        // 处理当前层的所有节点
        for (int i = 0; i < levelSize; i++) {
            TreeNode* node = q.front();
            q.pop();
            
            currentLevel.push_back(node->val);
            
            // 将下一层的节点入队
            if (node->left) q.push(node->left);
            if (node->right) q.push(node->right);
        }
        
        result.push_back(currentLevel);
    }
    
    return result;
}
```

## 4. 二叉树的常见操作

### 4.1 查找节点

```cpp
// 在二叉树中查找值为target的节点
TreeNode* findNode(TreeNode* root, int target) {
    if (root == nullptr || root->val == target)
        return root;
    
    // 先在左子树中查找
    TreeNode* leftResult = findNode(root->left, target);
    if (leftResult != nullptr)
        return leftResult;
    
    // 若左子树中未找到，则在右子树中查找
    return findNode(root->right, target);
}
```

### 4.2 计算二叉树高度

```cpp
// 计算二叉树的高度
int height(TreeNode* root) {
    if (root == nullptr)
        return 0;
    
    // 递归计算左右子树的高度，取最大值加1
    int leftHeight = height(root->left);
    int rightHeight = height(root->right);
    
    return max(leftHeight, rightHeight) + 1;  // +1是算上当前节点这一层
}
```

### 4.3 计算节点个数

```cpp
// 计算二叉树的节点个数
int countNodes(TreeNode* root) {
    if (root == nullptr)
        return 0;
    
    // 节点总数 = 左子树节点数 + 右子树节点数 + 1(根节点)
    return countNodes(root->left) + countNodes(root->right) + 1;
}
```

## 5. ACM常见题型与解法

### 5.1 最大路径和

【问题】：找出二叉树中的一条路径，使得路径上所有节点值之和最大。

```cpp
// 求二叉树的最大路径和
int maxPathSum(TreeNode* root) {
    int maxSum = INT_MIN;
    maxPathSumHelper(root, maxSum);
    return maxSum;
}

// 辅助函数，计算从当前节点出发的最大路径和
int maxPathSumHelper(TreeNode* node, int& maxSum) {
    if (node == nullptr) return 0;
    
    // 计算左右子树的最大贡献值（负值的贡献会被当作0）
    int leftGain = max(maxPathSumHelper(node->left, maxSum), 0);
    int rightGain = max(maxPathSumHelper(node->right, maxSum), 0);
    
    // 计算当前节点的最大路径和（节点值 + 左子树贡献 + 右子树贡献）
    int currentPathSum = node->val + leftGain + rightGain;
    
    // 更新全局最大路径和
    maxSum = max(maxSum, currentPathSum);
    
    // 返回以当前节点为端点的最大贡献值（只能选择左或右子树中的一条路径）
    return node->val + max(leftGain, rightGain);
}
```

【复杂度分析】：
- 时间复杂度：O(n)，每个节点被访问一次
- 空间复杂度：O(h)，h为树的高度，最坏情况下为O(n)

### 5.2 二叉树的序列化与反序列化

【问题】：设计一种算法，将二叉树序列化为字符串，并能从该字符串反序列化恢复原始二叉树。

```cpp
// 序列化二叉树
string serialize(TreeNode* root) {
    if (root == nullptr) return "null,";
    
    // 使用前序遍历进行序列化
    string result = to_string(root->val) + ",";
    result += serialize(root->left);
    result += serialize(root->right);
    
    return result;
}

// 反序列化二叉树
TreeNode* deserialize(string data) {
    vector<string> nodes;
    string tmp;
    
    // 将字符串分割为节点值列表
    for (char c : data) {
        if (c == ',') {
            nodes.push_back(tmp);
            tmp.clear();
        } else {
            tmp += c;
        }
    }
    
    int index = 0;
    return deserializeHelper(nodes, index);
}

TreeNode* deserializeHelper(vector<string>& nodes, int& index) {
    if (index >= nodes.size() || nodes[index] == "null") {
        index++;
        return nullptr;
    }
    
    // 创建当前节点
    TreeNode* root = new TreeNode(stoi(nodes[index++]));
    
    // 递归构建左右子树
    root->left = deserializeHelper(nodes, index);
    root->right = deserializeHelper(nodes, index);
    
    return root;
}
```

【复杂度分析】：
- 序列化时间复杂度：O(n)
- 序列化空间复杂度：O(n)
- 反序列化时间复杂度：O(n)
- 反序列化空间复杂度：O(n)

### 5.3 二叉树的最近公共祖先

【问题】：找出二叉树中两个节点的最近公共祖先。

```cpp
// 查找二叉树中两个节点的最近公共祖先
TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
    // 基本情况
    if (root == nullptr || root == p || root == q)
        return root;
    
    // 在左右子树中查找p和q
    TreeNode* leftLCA = lowestCommonAncestor(root->left, p, q);
    TreeNode* rightLCA = lowestCommonAncestor(root->right, p, q);
    
    // 如果p和q分别在左右子树中，则当前节点为LCA
    if (leftLCA != nullptr && rightLCA != nullptr)
        return root;
    
    // 否则，LCA在左子树或右子树中
    return (leftLCA != nullptr) ? leftLCA : rightLCA;
}
```

【复杂度分析】：
- 时间复杂度：O(n)，n为节点数量
- 空间复杂度：O(h)，h为树高，最坏情况下为O(n)

## 6. 二叉搜索树 (BST)

【二叉搜索树】是特殊的二叉树，满足以下性质：
- 左子树上所有节点的值均小于根节点的值
- 右子树上所有节点的值均大于根节点的值
- 左右子树也分别是二叉搜索树

### 6.1 BST的查找操作

```cpp
// 在BST中查找值为target的节点
TreeNode* searchBST(TreeNode* root, int target) {
    // 基本情况
    if (root == nullptr || root->val == target)
        return root;
    
    // 根据BST性质，在左右子树中二分查找
    if (target < root->val)
        return searchBST(root->left, target);  // 在左子树中查找
    else
        return searchBST(root->right, target); // 在右子树中查找
}
```

### 6.2 BST的插入操作

```cpp
// 在BST中插入值为val的新节点
TreeNode* insertIntoBST(TreeNode* root, int val) {
    if (root == nullptr)
        return new TreeNode(val);
    
    // 根据BST性质，确定插入位置
    if (val < root->val)
        root->left = insertIntoBST(root->left, val);  // 插入到左子树
    else if (val > root->val)
        root->right = insertIntoBST(root->right, val); // 插入到右子树
    
    return root;
}
```

### 6.3 BST的删除操作

```cpp
// 在BST中删除值为key的节点
TreeNode* deleteNode(TreeNode* root, int key) {
    if (root == nullptr) return nullptr;
    
    // 查找要删除的节点
    if (key < root->val) {
        root->left = deleteNode(root->left, key);
    } else if (key > root->val) {
        root->right = deleteNode(root->right, key);
    } else {
        // 找到了要删除的节点
        
        // 情况1：叶子节点
        if (root->left == nullptr && root->right == nullptr) {
            delete root;
            return nullptr;
        }
        
        // 情况2：只有一个子节点
        if (root->left == nullptr) {
            TreeNode* temp = root->right;
            delete root;
            return temp;
        }
        if (root->right == nullptr) {
            TreeNode* temp = root->left;
            delete root;
            return temp;
        }
        
        // 情况3：有两个子节点，找右子树中的最小节点（或左子树中的最大节点）
        TreeNode* temp = findMin(root->right);
        root->val = temp->val;  // 用后继节点的值替换当前节点
        root->right = deleteNode(root->right, temp->val);  // 删除后继节点
    }
    
    return root;
}

// 查找以root为根的子树中的最小节点
TreeNode* findMin(TreeNode* root) {
    while (root->left != nullptr)
        root = root->left;
    return root;
}
```

## 7. 二叉树的内存管理

### 7.1 释放二叉树内存

```cpp
// 释放整棵二叉树的内存
void deleteBinaryTree(TreeNode* root) {
    if (root == nullptr) return;
    
    // 后序遍历删除（先删除子树）
    deleteBinaryTree(root->left);
    deleteBinaryTree(root->right);
    
    // 最后删除根节点
    delete root;
}
```

## 8. 易错点和调试技巧

### 8.1 易错点
- 【空指针检查】：始终检查节点是否为nullptr再进行操作
- 【递归基础情况】：确保所有递归函数都有正确的终止条件
- 【内存泄漏】：在析构或删除树时，确保所有动态分配的节点都被删除
- 【深度计算】：计算深度时是否从0开始或从1开始需明确

### 8.2 调试技巧
- 使用前中后序遍历打印树结构，验证树是否构建正确
- 对于复杂问题，先在纸上画出简单的测试用例
- 递归函数可以添加层级参数辅助调试，打印每次调用所处的层级

## 9. 补充材料

### 9.1 树的常见应用
- 文件系统：目录结构
- 表达式解析：表达式树
- 数据库：B树和B+树索引
- 编译器：抽象语法树
- 计算机网络：路由算法

### 9.2 进阶树结构
- AVL树：自平衡二叉搜索树
- 红黑树：自平衡二叉搜索树，平衡性能更好
- B树/B+树：多路搜索树，适合磁盘存储
- 线段树：用于区间查询
- 字典树：用于高效的字符串查找
