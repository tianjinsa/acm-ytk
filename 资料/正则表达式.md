# 正则表达式详细使用文档

## 目录

1. [基础概念](#基础概念)
2. [基本语法](#基本语法)
3. [字符类](#字符类)
4. [量词](#量词)
5. [定位符](#定位符)
6. [分组和捕获](#分组和捕获)
7. [修饰符](#修饰符)
8. [常用模式](#常用模式)
9. [编程语言中的使用](#编程语言中的使用)
10. [实际应用示例](#实际应用示例)
11. [性能优化](#性能优化)
12. [调试技巧](#调试技巧)

## 基础概念

正则表达式（Regular Expression，简称 Regex 或 RegExp）是一种强大的文本模式匹配工具，用于在字符串中查找、替换或验证特定的模式。

### 正则表达式的用途

- 数据验证（如邮箱、电话号码格式）
- 文本搜索和替换
- 数据提取和解析
- 日志分析
- 代码重构

## 基本语法

### 字面字符

直接匹配字符本身：

```regex
abc      # 匹配字符串 "abc"
123      # 匹配字符串 "123"
```

### 特殊字符（元字符）

需要转义才能匹配字面意思：

```regex
. ^ $ * + ? { } [ ] \ | ( )
```

转义示例：

```regex
\.       # 匹配点号 "."
\$       # 匹配美元符号 "$"
\\       # 匹配反斜杠 "\"
```

## 字符类

### 基本字符类

```regex
.        # 匹配任意单个字符（除换行符）
\d       # 匹配数字 [0-9]
\D       # 匹配非数字 [^0-9]
\w       # 匹配单词字符 [a-zA-Z0-9_]
\W       # 匹配非单词字符 [^a-zA-Z0-9_]
\s       # 匹配空白字符（空格、制表符、换行符等）
\S       # 匹配非空白字符
```

### 自定义字符类

```regex
[abc]     # 匹配 a、b 或 c 中的任意一个
[^abc]    # 匹配除 a、b、c 之外的任意字符
[a-z]     # 匹配小写字母 a 到 z
[A-Z]     # 匹配大写字母 A 到 Z
[0-9]     # 匹配数字 0 到 9
[a-zA-Z]  # 匹配所有字母
[a-zA-Z0-9] # 匹配字母和数字
```

### 特殊字符类

```regex
\t       # 制表符
\n       # 换行符
\r       # 回车符
\f       # 换页符
\v       # 垂直制表符
```

## 量词

### 基本量词

```regex
*        # 匹配前面的字符 0 次或多次
+        # 匹配前面的字符 1 次或多次
?        # 匹配前面的字符 0 次或 1 次
{n}      # 匹配前面的字符恰好 n 次
{n,}     # 匹配前面的字符至少 n 次
{n,m}    # 匹配前面的字符 n 到 m 次
```

### 贪婪与非贪婪匹配

```regex
*?       # 非贪婪匹配 0 次或多次
+?       # 非贪婪匹配 1 次或多次
??       # 非贪婪匹配 0 次或 1 次
{n,m}?   # 非贪婪匹配 n 到 m 次
```

示例：

```regex
文本: "hello world"
贪婪: h.*o     # 匹配 "hello wo"
非贪婪: h.*?o   # 匹配 "hello"
```

## 定位符

### 边界匹配

```regex
^        # 行的开始
$        # 行的结束
\b       # 单词边界
\B       # 非单词边界
\A       # 字符串开始（多行模式下与 ^ 不同）
\Z       # 字符串结束（多行模式下与 $ 不同）
```

示例：

```regex
^hello   # 匹配以 "hello" 开头的行
world$   # 匹配以 "world" 结尾的行
\bcat\b  # 匹配完整单词 "cat"
```

## 分组和捕获

### 分组

```regex
(abc)    # 捕获组，匹配 "abc" 并捕获
(?:abc)  # 非捕获组，匹配 "abc" 但不捕获
```

### 后向引用

```regex
(abc)\1  # 匹配 "abc" 后跟相同的内容
(\w+)\s+\1  # 匹配重复的单词
```

### 命名捕获组

```regex
(?<name>pattern)    # 命名捕获组
(?P<name>pattern)   # Python 风格命名捕获组
```

## 修饰符

### 常用修饰符

```regex
i        # 忽略大小写
g        # 全局匹配
m        # 多行模式
s        # 单行模式（. 匹配换行符）
x        # 忽略空白字符和注释
```

## 常用模式

### 邮箱验证

```regex
^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$
```

### 手机号码（中国）

```regex
^1[3-9]\d{9}$
```

### URL 匹配

```regex
^https?:\/\/(www\.)?[-a-zA-Z0-9@:%._\+~#=]{1,256}\.[a-zA-Z0-9()]{1,6}\b([-a-zA-Z0-9()@:%_\+.~#?&//=]*)$
```

### IP 地址

```regex
^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$
```

### 身份证号码（中国）

```regex
^[1-9]\d{5}(18|19|20)\d{2}((0[1-9])|(1[0-2]))(([0-2][1-9])|10|20|30|31)\d{3}[0-9Xx]$
```

### 密码强度（至少8位，包含大小写字母、数字和特殊字符）

```regex
^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]{8,}$
```

### 日期格式（YYYY-MM-DD）

```regex
^\d{4}-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])$
```

### 时间格式（HH:MM:SS）

```regex
^([01]?[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9]$
```

## 编程语言中的使用

### JavaScript

```javascript
// 创建正则表达式
const regex1 = /pattern/flags;
const regex2 = new RegExp('pattern', 'flags');

// 匹配方法
const str = "hello world";
str.match(/hello/);        // 返回匹配结果
str.search(/world/);       // 返回匹配位置
str.replace(/hello/, 'hi'); // 替换
/hello/.test(str);         // 测试是否匹配
```

### Python

```python
import re

# 匹配方法
text = "hello world"
re.match(r'hello', text)      # 从开头匹配
re.search(r'world', text)     # 查找匹配
re.findall(r'\w+', text)      # 查找所有匹配
re.sub(r'hello', 'hi', text)  # 替换

# 编译正则表达式
pattern = re.compile(r'\d+')
pattern.findall(text)
```

### Java

```java
import java.util.regex.*;

String text = "hello world";
Pattern pattern = Pattern.compile("hello");
Matcher matcher = pattern.matcher(text);

if (matcher.find()) {
    System.out.println("匹配成功");
}

// 替换
String result = text.replaceAll("hello", "hi");
```

### C Sharp

```csharp
using System.Text.RegularExpressions;

string text = "hello world";
Regex regex = new Regex(@"hello");

bool isMatch = regex.IsMatch(text);
Match match = regex.Match(text);
string result = regex.Replace(text, "hi");
```

## 实际应用示例

### 1. 数据清理

```python
import re

# 清理电话号码格式
def clean_phone(phone):
    # 移除所有非数字字符
    return re.sub(r'[^\d]', '', phone)

phone = "(123) 456-7890"
clean_phone(phone)  # "1234567890"
```

### 2. 日志分析

```python
import re

log_pattern = r'(\d{4}-\d{2}-\d{2}) (\d{2}:\d{2}:\d{2}) \[(\w+)\] (.+)'
log_line = "2023-12-01 14:30:25 [ERROR] Database connection failed"

match = re.match(log_pattern, log_line)
if match:
    date, time, level, message = match.groups()
    print(f"日期: {date}, 时间: {time}, 级别: {level}, 消息: {message}")
```

### 3. 文本提取

```python
import re

# 提取邮箱地址
text = "联系我们：admin@example.com 或 support@test.org"
emails = re.findall(r'\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b', text)
print(emails)  # ['admin@example.com', 'support@test.org']
```

### 4. 配置文件解析

```python
import re

config_text = """
name=myapp
version=1.0.0
debug=true
port=8080
"""

# 解析键值对
config_pattern = r'^(\w+)=(.+)$'
config = {}
for line in config_text.strip().split('\n'):
    match = re.match(config_pattern, line)
    if match:
        key, value = match.groups()
        config[key] = value

print(config)
```

## 性能优化

### 1. 编译正则表达式

```python
# 不好的做法
for item in items:
    if re.match(r'\d+', item):
        process(item)

# 好的做法
pattern = re.compile(r'\d+')
for item in items:
    if pattern.match(item):
        process(item)
```

### 2. 避免回溯

```regex
# 可能导致回溯的模式
(a+)+b

# 更好的模式
a+b
```

### 3. 使用非捕获组

```regex
# 如果不需要捕获，使用非捕获组
(?:abc)+

# 而不是
(abc)+
```

### 4. 锚定匹配

```regex
# 使用锚定符提高性能
^pattern$

# 而不是仅仅
pattern
```

## 调试技巧

### 1. 在线测试工具

- [Regex101](https://regex101.com/)
- [RegExr](https://regexr.com/)
- [RegexPal](https://www.regexpal.com/)

### 2. 分步构建

```regex
# 从简单开始
\d           # 匹配数字
\d{3}        # 匹配3位数字
\d{3}-       # 匹配3位数字加横线
\d{3}-\d{3}  # 匹配电话号码格式
```

### 3. 使用详细模式

```python
import re

# 使用 re.VERBOSE 标志使正则表达式更易读
pattern = re.compile(r'''
    ^                   # 行开始
    (\d{4})             # 年份
    -                   # 分隔符
    (0[1-9]|1[0-2])     # 月份
    -                   # 分隔符
    (0[1-9]|[12]\d|3[01]) # 日期
    $                   # 行结束
''', re.VERBOSE)
```

### 4. 测试边界情况

```python
# 测试各种输入
test_cases = [
    "valid@example.com",
    "invalid.email",
    "user@domain",
    "@example.com",
    "user@.com"
]

email_pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
for test in test_cases:
    result = re.match(email_pattern, test)
    print(f"{test}: {'匹配' if result else '不匹配'}")
```

## 总结

正则表达式是一个强大的文本处理工具，掌握它需要：

1. **理解基本概念**：字符类、量词、定位符等
2. **练习常用模式**：邮箱、电话、URL 等验证
3. **注意性能**：编译正则、避免回溯
4. **充分测试**：使用在线工具和边界测试
5. **保持简单**：复杂的正则难以维护

记住：好的正则表达式应该是**准确**、**高效**、**可读**的。当正则表达式变得过于复杂时，考虑使用多个简单的正则或其他字符串处理方法。