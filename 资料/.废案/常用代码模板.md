# ACM竞赛常用代码模板

## 目录
1. [输入输出优化](#输入输出优化)
2. [数据结构模板](#数据结构模板)
3. [图论模板](#图论模板)
4. [数学模板](#数学模板)
5. [字符串模板](#字符串模板)
6. [动态规划模板](#动态规划模板)

## 输入输出优化

### C++输入输出加速
```cpp
// 关闭同步：禁用C和C++标准流的同步，可以加速输入输出
ios::sync_with_stdio(false);
cin.tie(nullptr);  // 解除cin与cout的绑定，进一步加速

// 使用快读：手动实现快速读取整数
inline int read() {
    int x = 0, f = 1;  // x存储结果，f表示符号
    char ch = getchar();  // 读入一个字符
    // 跳过非数字字符，直到找到一个数字或负号
    while(ch < '0' || ch > '9') {
        if(ch == '-') f = -1;  // 处理负号
        ch = getchar();
    }
    // 读入数字部分
    while(ch >= '0' && ch <= '9') {
        x = x * 10 + ch - '0';  // 构建数字
        ch = getchar();
    }
    return x * f;  // 应用符号并返回
}
```

## 数据结构模板

### 并查集
```cpp
// 并查集：用于高效处理元素分组和查询连通性
class UnionFind {
private:
    vector<int> parent;  // 存储每个元素的父节点
    vector<int> rank;    // 用于按秩合并
public:
    // 初始化：每个元素构成一个单独的集合
    UnionFind(int n) {
        parent.resize(n);
        rank.resize(n, 0);
        for (int i = 0; i < n; i++) parent[i] = i;
    }
    
    // 查找元素x所在集合的代表元素（带路径压缩）
    int find(int x) {
        return x == parent[x] ? x : (parent[x] = find(parent[x]));
    }
    
    // 合并元素x和y所在的集合
    bool unite(int x, int y) {
        x = find(x);  // 找到x的代表元素
        y = find(y);  // 找到y的代表元素
        if (x == y) return false;  // 已经在同一集合中
        
        // 按秩合并：将较小的树连接到较大的树上
        if (rank[x] < rank[y]) {
            parent[x] = y;
        } else {
            parent[y] = x;
            if (rank[x] == rank[y]) rank[x]++;  // 如果秩相同，则增加根节点的秩
        }
        return true;  // 合并成功
    }
    
    // 判断x和y是否在同一集合中
    bool same(int x, int y) {
        return find(x) == find(y);
    }
};
```

### 树状数组
```cpp
// 树状数组：用于高效处理区间查询和单点修改
class BIT {
private:
    vector<int> tree;  // 存储树状数组
    int n;             // 数组大小
    
    // 计算最低位的1，用于更新和查询
    int lowbit(int x) {
        return x & (-x);  // 返回x的二进制表示中最低位的1所对应的值
    }
    
public:
    BIT(int size) : n(size) {
        tree.resize(n + 1, 0);  // 索引从1开始
    }
    
    // 更新单点值：在位置pos上加上val
    void update(int pos, int val) {
        while (pos <= n) {
            tree[pos] += val;  // 更新当前节点
            pos += lowbit(pos);  // 移动到负责更高区域的节点
        }
    }
    
    // 查询前缀和：计算从1到pos的元素和
    int query(int pos) {
        int sum = 0;
        while (pos > 0) {
            sum += tree[pos];  // 累加当前节点的值
            pos -= lowbit(pos);  // 移动到负责更低区域的节点
        }
        return sum;
    }
    
    // 计算区间[l,r]的和
    int rangeQuery(int l, int r) {
        return query(r) - query(l - 1);
    }
};
```

### 线段树
```cpp
// 线段树：用于高效处理区间修改和查询操作
class SegmentTree {
private:
    vector<int> tree;  // 存储区间值
    vector<int> lazy;  // 懒惰标记
    int n;             // 原数组大小
    
    // 下推懒惰标记
    void pushDown(int node, int start, int end) {
        if (lazy[node] != 0) {
            // 更新当前节点的值
            tree[node] += (end - start + 1) * lazy[node];
            
            // 如果不是叶子节点，将懒惰标记传递给子节点
            if (start != end) {
                lazy[node * 2] += lazy[node];  // 左子节点
                lazy[node * 2 + 1] += lazy[node];  // 右子节点
            }
            
            lazy[node] = 0;  // 清除当前节点的懒惰标记
        }
    }
    
public:
    SegmentTree(int size) {
        n = size;
        tree.resize(4 * n, 0);  // 线段树大小约为4倍原数组大小
        lazy.resize(4 * n, 0);
    }
    
    // 构建线段树
    void build(int node, int start, int end, const vector<int>& arr) {
        if (start == end) {
            // 叶子节点，直接赋值
            tree[node] = arr[start];
            return;
        }
        
        // 递归构建左右子树
        int mid = (start + end) / 2;
        build(node * 2, start, mid, arr);  // 左子树
        build(node * 2 + 1, mid + 1, end, arr);  // 右子树
        
        // 当前节点的值为左右子节点的和
        tree[node] = tree[node * 2] + tree[node * 2 + 1];
    }
    
    // 区间更新：将区间[l,r]中的每个元素加上val
    void update(int node, int start, int end, int l, int r, int val) {
        // 下推懒惰标记
        pushDown(node, start, end);
        
        // 无交集，直接返回
        if (start > r || end < l) return;
        
        // 完全包含，设置懒惰标记
        if (l <= start && end <= r) {
            lazy[node] += val;
            pushDown(node, start, end);
            return;
        }
        
        // 部分交集，递归更新左右子树
        int mid = (start + end) / 2;
        update(node * 2, start, mid, l, r, val);
        update(node * 2 + 1, mid + 1, end, l, r, val);
        
        // 更新当前节点
        tree[node] = tree[node * 2] + tree[node * 2 + 1];
    }
    
    // 区间查询：计算区间[l,r]的和
    int query(int node, int start, int end, int l, int r) {
        // 无交集
        if (start > r || end < l) return 0;
        
        // 下推懒惰标记
        pushDown(node, start, end);
        
        // 完全包含
        if (l <= start && end <= r) return tree[node];
        
        // 部分交集，递归查询左右子树
        int mid = (start + end) / 2;
        int leftSum = query(node * 2, start, mid, l, r);
        int rightSum = query(node * 2 + 1, mid + 1, end, l, r);
        
        return leftSum + rightSum;  // 返回区间和
    }
};
```

### 单调栈
```cpp
// 单调栈：处理下一个更大/更小元素问题
vector<int> nextGreaterElement(vector<int>& nums) {
    int n = nums.size();
    vector<int> result(n, -1);  // 初始化结果数组，默认-1表示没有更大元素
    stack<int> s;  // 存储元素索引
    
    // 从左到右遍历
    for (int i = 0; i < n; i++) {
        // 当栈不为空且当前元素大于栈顶元素时，不断弹出栈顶并更新结果
        while (!s.empty() && nums[i] > nums[s.top()]) {
            result[s.top()] = nums[i];  // 更新栈顶元素的下一个更大元素
            s.pop();  // 弹出已经处理的元素
        }
        s.push(i);  // 将当前索引入栈
    }
    
    return result;
}
```

### 单调队列
```cpp
// 单调队列：处理滑动窗口内的最大/最小值
vector<int> maxSlidingWindow(vector<int>& nums, int k) {
    vector<int> result;
    deque<int> q;  // 双端队列存储元素下标
    
    for (int i = 0; i < nums.size(); i++) {
        // 移除队列中不在当前窗口的元素
        while (!q.empty() && q.front() < i - k + 1) {
            q.pop_front();
        }
        
        // 保持队列单调递减：移除所有比当前元素小的元素
        while (!q.empty() && nums[q.back()] < nums[i]) {
            q.pop_back();
        }
        
        q.push_back(i);  // 添加当前元素到队列
        
        // 当窗口形成后（从第k-1个元素开始），记录当前窗口的最大值
        if (i >= k - 1) {
            result.push_back(nums[q.front()]);  // 队首元素即为当前窗口最大值
        }
    }
    
    return result;
}
```

## 图论模板

### 深度优先搜索(DFS)
```cpp
// 深度优先搜索：递归版本
void dfs(vector<vector<int>>& graph, int start, vector<bool>& visited) {
    // 标记当前节点为已访问
    visited[start] = true;
    cout << "访问节点: " << start << endl;
    
    // 递归访问所有未访问的邻接节点
    for (int neighbor : graph[start]) {
        if (!visited[neighbor]) {
            dfs(graph, neighbor, visited);
        }
    }
}

// DFS的主函数，处理非连通图
void dfsTraversal(vector<vector<int>>& graph) {
    int n = graph.size();  // 图中节点数量
    vector<bool> visited(n, false);  // 标记节点是否被访问
    
    // 对每个未访问的节点进行DFS
    for (int i = 0; i < n; i++) {
        if (!visited[i]) {
            dfs(graph, i, visited);
        }
    }
}

// 深度优先搜索：非递归版本（使用栈）
void dfsNonRecursive(vector<vector<int>>& graph, int start) {
    int n = graph.size();
    vector<bool> visited(n, false);
    stack<int> s;
    
    s.push(start);  // 将起始节点入栈
    visited[start] = true;  // 标记为已访问
    cout << "访问节点: " << start << endl;
    
    while (!s.empty()) {
        int node = s.top();
        
        // 查找一个未访问的邻接节点
        bool foundUnvisited = false;
        for (int neighbor : graph[node]) {
            if (!visited[neighbor]) {
                visited[neighbor] = true;
                cout << "访问节点: " << neighbor << endl;
                s.push(neighbor);
                foundUnvisited = true;
                break;
            }
        }
        
        // 如果没有未访问的邻接节点，则回溯（弹出栈顶）
        if (!foundUnvisited) {
            s.pop();
        }
    }
}
```

### 广度优先搜索(BFS)
```cpp
// 广度优先搜索
void bfs(vector<vector<int>>& graph, int start) {
    int n = graph.size();  // 图中节点数量
    vector<bool> visited(n, false);  // 标记节点是否被访问
    queue<int> q;  // 队列用于BFS
    
    // 将起始节点加入队列并标记为已访问
    q.push(start);
    visited[start] = true;
    
    // 当队列非空时继续搜索
    while (!q.empty()) {
        int node = q.front();  // 获取队首节点
        q.pop();  // 出队
        
        cout << "访问节点: " << node << endl;
        
        // 将所有未访问的邻接节点加入队列
        for (int neighbor : graph[node]) {
            if (!visited[neighbor]) {
                visited[neighbor] = true;  // 标记为已访问
                q.push(neighbor);  // 加入队列
            }
        }
    }
}

// BFS的主函数，处理非连通图
void bfsTraversal(vector<vector<int>>& graph) {
    int n = graph.size();
    vector<bool> visited(n, false);
    
    // 对每个未访问的节点进行BFS
    for (int i = 0; i < n; i++) {
        if (!visited[i]) {
            bfs(graph, i);
        }
    }
}

// 使用BFS计算最短路径（无权图）
vector<int> shortestPath(vector<vector<int>>& graph, int start) {
    int n = graph.size();
    vector<int> distance(n, -1);  // -1表示未访问
    vector<int> parent(n, -1);    // 记录路径
    queue<int> q;
    
    distance[start] = 0;  // 起点到自身距离为0
    q.push(start);
    
    while (!q.empty()) {
        int node = q.front();
        q.pop();
        
        for (int neighbor : graph[node]) {
            if (distance[neighbor] == -1) {  // 未访问
                distance[neighbor] = distance[node] + 1;  // 更新距离
                parent[neighbor] = node;  // 记录路径
                q.push(neighbor);
            }
        }
    }
    
    return distance;  // 返回从起点到各点的距离
}
```

### Dijkstra算法
```cpp
// Dijkstra算法：计算单源最短路径（适用于非负权图）
vector<int> dijkstra(vector<vector<pair<int, int>>>& graph, int start) {
    int n = graph.size();  // 节点数量
    vector<int> dist(n, INT_MAX);  // 存储从起点到各点的距离，初始化为无穷大
    dist[start] = 0;  // 起点到自身距离为0
    
    // 优先队列，pair<距离, 节点>，按距离从小到大排序
    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<>> pq;
    pq.push({0, start});  // 将起点加入队列
    
    while (!pq.empty()) {
        int d = pq.top().first;  // 当前最小距离
        int node = pq.top().second;  // 当前节点
        pq.pop();
        
        // 如果已经找到更短的路径，跳过
        if (d > dist[node]) continue;
        
        // 遍历所有邻接边
        for (auto& edge : graph[node]) {
            int neighbor = edge.first;    // 邻接节点
            int weight = edge.second;     // 边权重
            
            // 如果通过当前节点可以获得更短的路径
            if (dist[node] + weight < dist[neighbor]) {
                dist[neighbor] = dist[node] + weight;  // 更新距离
                pq.push({dist[neighbor], neighbor});   // 加入队列
            }
        }
    }
    
    return dist;  // 返回从起点到各点的最短距离
}
```

### Bellman-Ford算法
```cpp
// Bellman-Ford算法：计算单源最短路径（可处理负权图，检测负环）
vector<int> bellmanFord(int n, vector<vector<int>>& edges, int start) {
    vector<int> dist(n, INT_MAX);  // 存储从起点到各点的距离
    dist[start] = 0;  // 起点到自身距离为0
    
    // 进行n-1次松弛操作
    for (int i = 0; i < n - 1; i++) {
        for (auto& edge : edges) {
            int u = edge[0];  // 起点
            int v = edge[1];  // 终点
            int w = edge[2];  // 权重
            
            // 松弛操作
            if (dist[u] != INT_MAX && dist[u] + w < dist[v]) {
                dist[v] = dist[u] + w;
            }
        }
    }
    
    // 检测负环：再进行一次松弛，如果还能更新，则存在负环
    for (auto& edge : edges) {
        int u = edge[0];
        int v = edge[1];
        int w = edge[2];
        
        if (dist[u] != INT_MAX && dist[u] + w < dist[v]) {
            // 存在负环，将影响的节点标记为负无穷
            cout << "图中存在负环！" << endl;
            return vector<int>();  // 返回空数组表示存在负环
        }
    }
    
    return dist;  // 返回从起点到各点的最短距离
}
```

### Floyd-Warshall算法
```cpp
// Floyd-Warshall算法：计算所有点对最短路径
void floydWarshall(vector<vector<int>>& dist) {
    int n = dist.size();  // 节点数量
    
    // 三重循环：k为中间节点，i为起点，j为终点
    for (int k = 0; k < n; k++) {
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                // 如果通过k可以得到更短的路径
                if (dist[i][k] != INT_MAX && dist[k][j] != INT_MAX && 
                    dist[i][k] + dist[k][j] < dist[i][j]) {
                    dist[i][j] = dist[i][k] + dist[k][j];
                }
            }
        }
    }
    
    // 检测负环：如果对角线上有负值，则存在负环
    for (int i = 0; i < n; i++) {
        if (dist[i][i] < 0) {
            cout << "图中存在负环！" << endl;
            return;
        }
    }
}
```

### Kruskal算法（最小生成树）
```cpp
// Kruskal算法：求最小生成树
int kruskal(int n, vector<vector<int>>& edges) {
    // 创建边集合并排序
    vector<tuple<int, int, int>> edgeList;  // (权重, 起点, 终点)
    for (auto& edge : edges) {
        edgeList.push_back({edge[2], edge[0], edge[1]});
    }
    sort(edgeList.begin(), edgeList.end());  // 按权重升序排序
    
    // 初始化并查集
    vector<int> parent(n);
    for (int i = 0; i < n; i++) {
        parent[i] = i;
    }
    
    // 并查集的查找函数
    auto find = [&](int x) -> int {
        return parent[x] == x ? x : (parent[x] = find(parent[x]));
    };
    
    int totalWeight = 0;  // 最小生成树的总权重
    int edgesAdded = 0;   // 已添加的边数
    
    // 遍历所有边
    for (auto [weight, u, v] : edgeList) {
        int rootU = find(u);
        int rootV = find(v);
        
        // 如果加入这条边不会形成环
        if (rootU != rootV) {
            parent[rootU] = rootV;  // 合并两个连通分量
            totalWeight += weight;  // 更新总权重
            edgesAdded++;           // 已添加边数加1
            
            // 当添加了n-1条边时，最小生成树已完成
            if (edgesAdded == n - 1) break;
        }
    }
    
    // 检查是否生成了完整的最小生成树
    if (edgesAdded != n - 1) {
        cout << "无法生成最小生成树！" << endl;
        return -1;
    }
    
    return totalWeight;  // 返回最小生成树的总权重
}
```

### Prim算法（最小生成树）
```cpp
// Prim算法：求最小生成树
int prim(vector<vector<pair<int, int>>>& graph) {
    int n = graph.size();  // 节点数量
    vector<bool> visited(n, false);  // 标记节点是否在生成树中
    vector<int> minWeight(n, INT_MAX);  // 记录到树的最小权重
    
    int totalWeight = 0;  // 最小生成树的总权重
    minWeight[0] = 0;  // 选择节点0作为起点
    
    for (int i = 0; i < n; i++) {
        // 找到未访问节点中权重最小的
        int u = -1;
        for (int j = 0; j < n; j++) {
            if (!visited[j] && (u == -1 || minWeight[j] < minWeight[u])) {
                u = j;
            }
        }
        
        // 如果没有找到合适的节点，说明图不连通
        if (u == -1 || minWeight[u] == INT_MAX) {
            cout << "无法生成最小生成树！" << endl;
            return -1;
        }
        
        // 将节点u加入生成树
        visited[u] = true;
        totalWeight += minWeight[u];
        
        // 更新与u相邻的未访问节点的最小权重
        for (auto& [v, weight] : graph[u]) {
            if (!visited[v] && weight < minWeight[v]) {
                minWeight[v] = weight;
            }
        }
    }
    
    return totalWeight;  // 返回最小生成树的总权重
}
```

## 数学模板

### 素数筛法
```cpp
// 埃拉托斯特尼筛法：找出范围内的所有素数
vector<bool> sieveOfEratosthenes(int n) {
    vector<bool> isPrime(n + 1, true);  // 标记数字是否为素数
    isPrime[0] = isPrime[1] = false;    // 0和1不是素数
    
    // 从2开始遍历到sqrt(n)
    for (int i = 2; i * i <= n; i++) {
        if (isPrime[i]) {  // 如果i是素数
            // 将i的所有倍数标记为非素数
            for (int j = i * i; j <= n; j += i) {
                isPrime[j] = false;
            }
        }
    }
    
    return isPrime;  // 返回标记数组
}

// 线性筛法（欧拉筛）：更高效地找出素数
vector<int> linearSieve(int n) {
    vector<bool> isPrime(n + 1, true);  // 标记数字是否为素数
    vector<int> primes;  // 存储找到的素数
    
    isPrime[0] = isPrime[1] = false;
    
    for (int i = 2; i <= n; i++) {
        // 如果i是素数，将其加入素数列表
        if (isPrime[i]) {
            primes.push_back(i);
        }
        
        // 用已知的素数去筛选倍数
        for (int j = 0; j < primes.size() && i * primes[j] <= n; j++) {
            isPrime[i * primes[j]] = false;  // 标记为非素数
            
            // 如果i是primes[j]的倍数，停止循环
            // 这是保证每个合数只被其最小质因数筛掉
            if (i % primes[j] == 0) break;
        }
    }
    
    return primes;  // 返回素数列表
}
```

### GCD和LCM
```cpp
// 计算最大公约数 (GCD)
int gcd(int a, int b) {
    return b == 0 ? a : gcd(b, a % b);
}

// 计算最小公倍数 (LCM)
int lcm(int a, int b) {
    return a / gcd(a, b) * b;  // 先除以gcd避免溢出
}

// 扩展欧几里得算法：求解ax + by = gcd(a, b)
pair<int, int> extendedGcd(int a, int b) {
    if (b == 0) {
        return {1, 0};  // 基础情况：ax + by = a，解为x=1, y=0
    }
    
    auto [x, y] = extendedGcd(b, a % b);
    
    // 递归关系：gcd(a, b) = gcd(b, a%b)
    // ax + by = gcd(a, b) = gcd(b, a%b) = bx' + (a%b)y'
    // 其中 a%b = a - b * floor(a/b)，所以：
    // ax + by = bx' + (a - b * floor(a/b))y'
    //         = bx' + ay' - b * floor(a/b) * y'
    //         = ay' + b(x' - floor(a/b) * y')
    // 比较系数，得出：x = y'，y = x' - floor(a/b) * y'
    
    return {y, x - (a / b) * y};
}

// 求模逆元：ax ≡ 1 (mod m)，返回x
int modInverse(int a, int m) {
    // 要求a和m互质，否则不存在逆元
    auto [x, y] = extendedGcd(a, m);
    return (x % m + m) % m;  // 处理负数情况
}
```

### 快速幂
```cpp
// 快速幂算法：计算(base^exponent) % mod
long long fastPow(long long base, long long exponent, long long mod) {
    long long result = 1;
    base %= mod;  // 取模，避免base过大
    
    while (exponent > 0) {
        // 如果exponent的末位为1，将base乘入结果
        if (exponent & 1) {
            result = (result * base) % mod;
        }
        
        // 将base平方
        base = (base * base) % mod;
        
        // 指数除以2（右移一位）
        exponent >>= 1;
    }
    
    return result;
}
```

### 组合数学
```cpp
// 计算组合数C(n,k) = n! / (k! * (n-k)!)
long long combination(int n, int k, long long mod) {
    if (k > n) return 0;
    long long result = 1;
    for (int i = 1; i <= k; i++) {
        result = result * (n - i + 1) / i;
    }
    return result % mod;
}
```