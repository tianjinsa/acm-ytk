# 基础数据结构

## 并查集

### 算法设计思路

【并查集】是一种树形数据结构，用于处理**不相交集合**的合并及查询问题。其核心操作有两个：
- **查找(Find)**：确定元素属于哪一个集合
- **合并(Union)**：将两个集合合并为一个

并查集特别适合解决连通性问题，如判断两个节点是否连通、网络中节点的连通分量等。

### 代码实现与逻辑拆解

基本并查集实现：

```cpp
// 初始化，每个元素构成一个单独的集合
void init(int n) {
    for (int i = 0; i < n; i++) {
        parent[i] = i; // 每个节点的父节点初始化为自己
    }
}

// 查找元素所在集合（即根节点）
int find(int x) {
    if (parent[x] == x) return x; // 如果是根节点，直接返回
    return find(parent[x]); // 递归查找父节点
}

// 合并两个集合
void unite(int x, int y) {
    x = find(x); // 找到x的根节点
    y = find(y); // 找到y的根节点
    if (x != y) { // 如果不在同一个集合
        parent[y] = x; // 将y的根节点连接到x的根节点
    }
}
```

**优化后的并查集**（路径压缩 + 按秩合并）：

```cpp
int parent[MAX_N]; // 存储父节点
int rank[MAX_N];   // 存储树的高度

// 初始化
void init(int n) {
    for (int i = 0; i < n; i++) {
        parent[i] = i;
        rank[i] = 0; // 初始高度为0
    }
}

// 路径压缩优化的查找
int find(int x) {
    if (parent[x] != x) {
        parent[x] = find(parent[x]); // 路径压缩
    }
    return parent[x];
}

// 按秩合并
void unite(int x, int y) {
    x = find(x);
    y = find(y);
    
    if (x == y) return;
    
    if (rank[x] < rank[y]) {
        parent[x] = y; // 将较矮的树连到较高的树下面
    } else {
        parent[y] = x;
        if (rank[x] == rank[y]) rank[x]++; // 如果高度相同，则新树高度+1
    }
}

// 判断是否在同一集合
bool same(int x, int y) {
    return find(x) == find(y);
}
```

### 关键语法特性解析

1. **递归实现**：基本的`find`操作使用递归查找根节点
2. **路径压缩**：将查找路径上的所有节点直接连接到根节点，优化后续查询
3. **按秩合并**：通过记录树的高度信息，总是将较小的树合并到较大的树上，避免树过高

### 复杂度分析

- **时间复杂度**：
  - 未优化时：最坏情况下`find`和`unite`都是O(n)
  - 路径压缩+按秩合并：接近O(1)，理论上是O(α(n))，其中α是阿克曼函数的反函数，实际应用中可以视为常数

- **空间复杂度**：O(n)，需要存储每个元素的父节点

### 应用实例

**例题：朋友圈问题**

给定一个N×N的矩阵M，表示班上N名学生的朋友关系。如果M[i][j] = 1，表示第i个和第j个学生是朋友，否则不是。如果两个学生是直接朋友，或者他们通过其他学生间接认识，那么他们属于同一个朋友圈。求班上共有多少个朋友圈。

```cpp
int findCircleNum(vector<vector<int>>& M) {
    int n = M.size();
    // 初始化并查集
    vector<int> parent(n);
    for (int i = 0; i < n; i++) {
        parent[i] = i;
    }
    
    // 合并朋友关系
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            if (M[i][j] == 1) {
                unite(parent, i, j);
            }
        }
    }
    
    // 计算朋友圈数量（即不相交集合的数量）
    int count = 0;
    for (int i = 0; i < n; i++) {
        if (parent[i] == i) {
            count++;
        }
    }
    
    return count;
}

// 辅助函数
int find(vector<int>& parent, int x) {
    if (parent[x] != x) {
        parent[x] = find(parent, parent[x]); // 路径压缩
    }
    return parent[x];
}

void unite(vector<int>& parent, int x, int y) {
    parent[find(parent, x)] = find(parent, y);
}
```

### 易错点与调试技巧

1. **忘记路径压缩**：在频繁查找的场景下，不使用路径压缩会导致性能问题
2. **秩的理解错误**：秩不一定代表树的深度，在路径压缩后，它只是一个启发式的值
3. **调试技巧**：打印每次操作后的父节点数组，验证合并和查找是否正确执行

## 单调栈和单调队列

### 算法设计思路

【单调栈】是一种特殊的栈，在栈的先进后出(LIFO)基础上，保证栈内元素单调递增或单调递减。
【单调队列】是一种特殊的队列，在队列的先进先出(FIFO)基础上，保证队列内元素单调递增或单调递减。

这两种数据结构常用于解决如下问题：
- 单调栈：寻找数组中每个元素的下一个更大/更小元素
- 单调队列：滑动窗口中的最大/最小值问题

### 代码实现与逻辑拆解

**单调栈示例（求数组中每个元素右侧第一个更大的元素）**：

```cpp
vector<int> nextGreaterElement(vector<int>& nums) {
    int n = nums.size();
    vector<int> result(n, -1); // 结果数组，初始化为-1（表示没有更大元素）
    stack<int> st; // 存储索引而非元素值
    
    for (int i = 0; i < n; i++) {
        // 当栈不为空且当前元素大于栈顶对应的元素时，弹出栈顶并更新结果
        while (!st.empty() && nums[i] > nums[st.top()]) {
            result[st.top()] = nums[i]; // 栈顶元素的下一个更大元素就是当前元素
            st.pop();
        }
        // 将当前索引入栈
        st.push(i);
    }
    
    return result;
}
```

**单调队列示例（求滑动窗口最大值）**：

```cpp
vector<int> maxSlidingWindow(vector<int>& nums, int k) {
    vector<int> result;
    deque<int> dq; // 双端队列，存储元素索引
    
    for (int i = 0; i < nums.size(); i++) {
        // 移除队列中超出窗口范围的元素
        if (!dq.empty() && dq.front() < i - k + 1) {
            dq.pop_front();
        }
        
        // 移除队列中所有小于当前元素的值（维持单调递减）
        while (!dq.empty() && nums[i] > nums[dq.back()]) {
            dq.pop_back();
        }
        
        // 将当前元素索引加入队列
        dq.push_back(i);
        
        // 当窗口已经形成时，队首就是窗口最大值
        if (i >= k - 1) {
            result.push_back(nums[dq.front()]);
        }
    }
    
    return result;
}
```

### 关键语法特性解析

1. **STL容器使用**：
   - `stack<int>`：用于实现单调栈
   - `deque<int>`：用于实现单调队列，支持两端操作

2. **栈操作**：
   - `push()`：入栈
   - `pop()`：出栈
   - `top()`：查看栈顶元素
   - `empty()`：检查栈是否为空

3. **双端队列操作**：
   - `push_front()/push_back()`：从队首/队尾添加元素
   - `pop_front()/pop_back()`：从队首/队尾移除元素
   - `front()/back()`：访问队首/队尾元素

### 复杂度分析

**单调栈**：
- **时间复杂度**：O(n)，每个元素最多入栈和出栈一次
- **空间复杂度**：O(n)，最坏情况下栈存储所有元素

**单调队列**：
- **时间复杂度**：O(n)，每个元素最多入队和出队一次
- **空间复杂度**：O(k)，队列最多存储k个元素（滑动窗口大小）

### 易错点与调试技巧

1. **边界条件处理**：注意空数组、单元素数组的处理
2. **索引与值的混淆**：栈/队列中存储的是索引还是值，要明确
3. **滑动窗口范围**：计算滑动窗口时的索引范围要准确
4. **调试技巧**：打印每一步栈/队列的内容，观察单调性是否维持

## 线段树

### 算法设计思路

【线段树】是一种二叉树数据结构，用于高效处理**区间查询**和**区间更新**问题。每个节点代表一个区间，父节点的区间是子节点区间的并集。

线段树常用于解决如下问题：
- 区间求和
- 区间最大/最小值
- 区间修改

### 代码实现与逻辑拆解

基本线段树实现（区间求和）：

```cpp
// 线段树节点
struct SegmentTreeNode {
    int start, end; // 区间范围
    int sum;        // 区间和
    SegmentTreeNode *left, *right; // 左右子节点
    
    SegmentTreeNode(int s, int e) : start(s), end(e), sum(0), left(nullptr), right(nullptr) {}
};

// 构建线段树
SegmentTreeNode* buildTree(vector<int>& nums, int start, int end) {
    if (start > end) return nullptr;
    
    SegmentTreeNode* root = new SegmentTreeNode(start, end);
    
    if (start == end) { // 叶节点
        root->sum = nums[start];
    } else {
        int mid = start + (end - start) / 2;
        root->left = buildTree(nums, start, mid);
        root->right = buildTree(nums, mid + 1, end);
        root->sum = root->left->sum + root->right->sum; // 父节点的和等于子节点的和
    }
    
    return root;
}

// 更新单点值
void update(SegmentTreeNode* root, int index, int val) {
    if (root == nullptr) return;
    
    if (root->start == root->end) { // 找到目标叶节点
        root->sum = val;
        return;
    }
    
    int mid = root->start + (root->end - root->start) / 2;
    if (index <= mid) {
        update(root->left, index, val);
    } else {
        update(root->right, index, val);
    }
    
    // 更新父节点的和
    root->sum = root->left->sum + root->right->sum;
}

// 查询区间和
int queryRange(SegmentTreeNode* root, int start, int end) {
    if (root == nullptr || start > root->end || end < root->start) return 0;
    
    if (start <= root->start && end >= root->end) { // 完全覆盖
        return root->sum;
    }
    
    // 部分覆盖，需要分别查询左右子树
    return queryRange(root->left, start, end) + queryRange(root->right, start, end);
}
```

**数组实现的线段树**（更节省空间，常用于竞赛）：

```cpp
const int MAX_N = 100005;
int tree[4 * MAX_N]; // 线段树数组，大小通常设为4倍原数组大小
int nums[MAX_N];     // 原始数据

// 构建线段树，node为当前节点编号，start和end为区间边界
void build(int node, int start, int end) {
    if (start == end) {
        tree[node] = nums[start];
        return;
    }
    
    int mid = start + (end - start) / 2;
    int leftNode = 2 * node;      // 左子节点编号
    int rightNode = 2 * node + 1; // 右子节点编号
    
    build(leftNode, start, mid);        // 构建左子树
    build(rightNode, mid + 1, end);     // 构建右子树
    
    tree[node] = tree[leftNode] + tree[rightNode]; // 合并子节点结果
}

// 更新操作
void update(int node, int start, int end, int idx, int val) {
    if (start == end) { // 找到目标叶节点
        nums[idx] = val;
        tree[node] = val;
        return;
    }
    
    int mid = start + (end - start) / 2;
    int leftNode = 2 * node;
    int rightNode = 2 * node + 1;
    
    if (idx <= mid) {
        update(leftNode, start, mid, idx, val);
    } else {
        update(rightNode, mid + 1, end, idx, val);
    }
    
    tree[node] = tree[leftNode] + tree[rightNode];
}

// 区间查询
int query(int node, int start, int end, int l, int r) {
    if (r < start || l > end) return 0; // 区间不重叠
    
    if (l <= start && r >= end) return tree[node]; // 当前区间被完全包含
    
    int mid = start + (end - start) / 2;
    int leftNode = 2 * node;
    int rightNode = 2 * node + 1;
    
    int leftSum = query(leftNode, start, mid, l, r);
    int rightSum = query(rightNode, mid + 1, end, l, r);
    
    return leftSum + rightSum;
}
```

### 关键语法特性解析

1. **递归构建**：线段树通过递归方式构建，每个节点代表一个区间
2. **区间划分**：父节点的区间被分为左右两个子区间
3. **数据聚合**：父节点存储的是子节点信息的聚合（如和、最大值等）
4. **延迟标记**：进阶实现中使用延迟标记来支持高效的区间更新

### 复杂度分析

- **构建时间**：O(n)，n为原始数组长度
- **单点更新**：O(log n)
- **区间查询**：O(log n)
- **区间更新**（使用延迟标记）：O(log n)
- **空间复杂度**：O(n)，指针实现；O(4n)≈O(n)，数组实现

### 应用实例

**例题：区间求和问题**

给定一个数组，实现两种操作：
1. `update(i, val)`：将索引i的值更新为val
2. `sumRange(i, j)`：计算区间[i, j]的元素和

```cpp
class NumArray {
private:
    vector<int> nums;
    vector<int> tree;
    int n;
    
    void buildTree(int node, int start, int end) {
        if (start == end) {
            tree[node] = nums[start];
            return;
        }
        
        int mid = start + (end - start) / 2;
        buildTree(2 * node, start, mid);
        buildTree(2 * node + 1, mid + 1, end);
        tree[node] = tree[2 * node] + tree[2 * node + 1];
    }
    
    void updateTree(int node, int start, int end, int idx, int val) {
        if (start == end) {
            nums[idx] = val;
            tree[node] = val;
            return;
        }
        
        int mid = start + (end - start) / 2;
        if (idx <= mid) {
            updateTree(2 * node, start, mid, idx, val);
        } else {
            updateTree(2 * node + 1, mid + 1, end, idx, val);
        }
        
        tree[node] = tree[2 * node] + tree[2 * node + 1];
    }
    
    int queryTree(int node, int start, int end, int l, int r) {
        if (r < start || l > end) return 0;
        if (l <= start && r >= end) return tree[node];
        
        int mid = start + (end - start) / 2;
        return queryTree(2 * node, start, mid, l, r) + 
               queryTree(2 * node + 1, mid + 1, end, l, r);
    }
    
public:
    NumArray(vector<int>& nums) {
        this->nums = nums;
        n = nums.size();
        // 线段树大小设为4倍原数组大小，足够容纳所有节点
        tree.resize(4 * n);
        buildTree(1, 0, n - 1);
    }
    
    void update(int index, int val) {
        updateTree(1, 0, n - 1, index, val);
    }
    
    int sumRange(int left, int right) {
        return queryTree(1, 0, n - 1, left, right);
    }
};
```

### 易错点与调试技巧

1. **索引混淆**：在数组实现中，容易混淆节点编号和原数组索引
2. **空间分配不足**：数组实现的线段树通常需要4倍原数组长度的空间
3. **区间边界**：处理查询和更新时的区间边界要小心
4. **调试技巧**：
   - 画出线段树结构，验证每个节点表示的区间范围
   - 打印每次操作后的树状态，检查节点值是否更新正确
