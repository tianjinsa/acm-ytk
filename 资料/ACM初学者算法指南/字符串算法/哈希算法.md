# 哈希算法

## 概述

【哈希算法】是一种将任意长度的数据映射为固定长度数据的算法。在竞赛编程中，哈希算法主要用于字符串匹配、数据去重、快速查找等场景。常见的应用包括字符串哈希、哈希表等。

## 哈希函数的基本性质

1. **确定性**：相同的输入必须产生相同的输出
2. **均匀性**：不同的输入应该尽可能均匀地分布在输出空间
3. **雪崩效应**：输入的微小变化应该导致输出的显著变化
4. **快速计算**：哈希值的计算应该高效

## 字符串哈希

### 多项式哈希法

多项式哈希是最常用的字符串哈希方法，将字符串看作一个p进制数。

```cpp
#include <iostream>
#include <string>
#include <vector>
using namespace std;

// 字符串哈希类
class StringHash {
private:
    static const long long MOD = 1e9 + 7;  // 模数
    static const long long BASE = 131;     // 进制基数
    
    vector<long long> hash;    // 前缀哈希值
    vector<long long> power;   // BASE的幂次
    
public:
    StringHash(const string& s) {
        int n = s.length();
        hash.resize(n + 1);
        power.resize(n + 1);
        
        hash[0] = 0;
        power[0] = 1;
        
        // 计算前缀哈希值
        for (int i = 0; i < n; i++) {
            hash[i + 1] = (hash[i] * BASE + s[i]) % MOD;
            power[i + 1] = (power[i] * BASE) % MOD;
        }
    }
    
    // 获取子串[l, r)的哈希值
    long long getHash(int l, int r) {
        long long result = (hash[r] - hash[l] * power[r - l] % MOD + MOD) % MOD;
        return result;
    }
};

// 示例：比较两个子串是否相等
int main() {
    string s = "abcabcabc";
    StringHash sh(s);
    
    // 比较子串s[0,3)和s[3,6)
    if (sh.getHash(0, 3) == sh.getHash(3, 6)) {
        cout << "子串相等" << endl;
    } else {
        cout << "子串不等" << endl;
    }
    
    return 0;
}
```

### 双哈希防冲突

使用两个不同的模数和基数可以有效减少哈希冲突。

```cpp
#include <iostream>
#include <string>
#include <vector>
using namespace std;

class DoubleStringHash {
private:
    static const long long MOD1 = 1e9 + 7;
    static const long long MOD2 = 1e9 + 9;
    static const long long BASE1 = 131;
    static const long long BASE2 = 137;
    
    vector<long long> hash1, hash2;
    vector<long long> power1, power2;
    
public:
    DoubleStringHash(const string& s) {
        int n = s.length();
        hash1.resize(n + 1);
        hash2.resize(n + 1);
        power1.resize(n + 1);
        power2.resize(n + 1);
        
        hash1[0] = hash2[0] = 0;
        power1[0] = power2[0] = 1;
        
        for (int i = 0; i < n; i++) {
            hash1[i + 1] = (hash1[i] * BASE1 + s[i]) % MOD1;
            hash2[i + 1] = (hash2[i] * BASE2 + s[i]) % MOD2;
            power1[i + 1] = (power1[i] * BASE1) % MOD1;
            power2[i + 1] = (power2[i] * BASE2) % MOD2;
        }
    }
    
    // 获取双哈希值
    pair<long long, long long> getHash(int l, int r) {
        long long h1 = (hash1[r] - hash1[l] * power1[r - l] % MOD1 + MOD1) % MOD1;
        long long h2 = (hash2[r] - hash2[l] * power2[r - l] % MOD2 + MOD2) % MOD2;
        return {h1, h2};
    }
};
```

## 滚动哈希

滚动哈希用于在滑动窗口中高效更新哈希值。

```cpp
#include <iostream>
#include <string>
using namespace std;

class RollingHash {
private:
    static const long long MOD = 1e9 + 7;
    static const long long BASE = 131;
    
    long long windowHash;  // 当前窗口的哈希值
    long long power;       // BASE^窗口大小
    int windowSize;
    
public:
    RollingHash(int size) : windowSize(size) {
        windowHash = 0;
        power = 1;
        for (int i = 0; i < size; i++) {
            power = (power * BASE) % MOD;
        }
    }
    
    // 添加新字符，移除旧字符
    void roll(char oldChar, char newChar) {
        // 移除最左边的字符
        windowHash = (windowHash - (oldChar * power % MOD) + MOD) % MOD;
        // 添加新字符
        windowHash = (windowHash * BASE + newChar) % MOD;
    }
    
    // 初始化窗口
    void init(const string& s, int start) {
        windowHash = 0;
        for (int i = 0; i < windowSize; i++) {
            windowHash = (windowHash * BASE + s[start + i]) % MOD;
        }
    }
    
    long long getHash() const {
        return windowHash;
    }
};

// 示例：找到所有与模式串相等的子串位置
vector<int> findAllOccurrences(const string& text, const string& pattern) {
    vector<int> result;
    if (pattern.length() > text.length()) return result;
    
    int patternLen = pattern.length();
    
    // 计算模式串的哈希值
    StringHash patternHash(pattern);
    long long targetHash = patternHash.getHash(0, patternLen);
    
    // 使用滚动哈希查找
    RollingHash textHash(patternLen);
    textHash.init(text, 0);
    
    if (textHash.getHash() == targetHash) {
        result.push_back(0);
    }
    
    // 滚动窗口
    for (int i = 1; i <= (int)text.length() - patternLen; i++) {
        textHash.roll(text[i - 1], text[i + patternLen - 1]);
        if (textHash.getHash() == targetHash) {
            result.push_back(i);
        }
    }
    
    return result;
}
```

## 哈希表的应用

### 自定义哈希函数

```cpp
#include <iostream>
#include <unordered_map>
#include <unordered_set>
using namespace std;

// 自定义pair的哈希函数
struct PairHash {
    size_t operator()(const pair<int, int>& p) const {
        return hash<int>()(p.first) ^ (hash<int>()(p.second) << 1);
    }
};

// 示例：使用自定义哈希的unordered_map
int main() {
    unordered_map<pair<int, int>, int, PairHash> pairMap;
    pairMap[{1, 2}] = 3;
    pairMap[{4, 5}] = 6;
    
    cout << "pairMap[{1,2}] = " << pairMap[{1, 2}] << endl;
    
    return 0;
}
```

### 字符串去重

```cpp
#include <iostream>
#include <vector>
#include <unordered_set>
#include <string>
using namespace std;

// 使用哈希去除重复字符串
vector<string> removeDuplicates(const vector<string>& strings) {
    unordered_set<string> seen;
    vector<string> result;
    
    for (const string& s : strings) {
        if (seen.find(s) == seen.end()) {
            seen.insert(s);
            result.push_back(s);
        }
    }
    
    return result;
}
```

## 经典应用题型

### 1. 字符串匹配问题

使用字符串哈希可以在O(n+m)时间内解决字符串匹配问题。

### 2. 最长重复子串

```cpp
#include <iostream>
#include <string>
#include <unordered_set>
using namespace std;

// 找到最长的重复子串
string longestRepeatedSubstring(const string& s) {
    int n = s.length();
    StringHash sh(s);
    
    string result = "";
    
    // 二分查找最长长度
    for (int len = 1; len <= n; len++) {
        unordered_set<long long> seen;
        bool found = false;
        
        for (int i = 0; i <= n - len; i++) {
            long long hash = sh.getHash(i, i + len);
            if (seen.count(hash)) {
                result = s.substr(i, len);
                found = true;
                break;
            }
            seen.insert(hash);
        }
        
        if (!found) break;
    }
    
    return result;
}
```

### 3. 回文串判断

```cpp
#include <iostream>
#include <string>
#include <algorithm>
using namespace std;

// 判断字符串是否为回文
bool isPalindrome(const string& s) {
    StringHash forward(s);
    string reversed = s;
    reverse(reversed.begin(), reversed.end());
    StringHash backward(reversed);
    
    int n = s.length();
    return forward.getHash(0, n) == backward.getHash(0, n);
}
```

## 注意事项与优化技巧

### 1. 模数选择
- 选择大质数作为模数，如1e9+7, 1e9+9
- 避免使用2的幂次作为模数

### 2. 基数选择
- 常用基数：131, 137, 13331
- 基数应该大于字符集大小

### 3. 冲突处理
- 使用双哈希降低冲突概率
- 在关键场合验证字符串实际内容

### 4. 溢出处理
```cpp
// 安全的模运算
long long safeMod(long long a, long long mod) {
    return ((a % mod) + mod) % mod;
}
```

## 时间复杂度分析

- **预处理时间**：O(n)
- **查询时间**：O(1)
- **空间复杂度**：O(n)

## 总结

哈希算法是竞赛编程中的重要工具，特别适用于字符串处理问题。掌握字符串哈希、滚动哈希等技术，能够高效解决许多看似复杂的字符串问题。在实际应用中，要注意选择合适的哈希函数参数，并考虑使用双哈希来减少冲突的影响。

## 推荐练习题

1. LeetCode 28. 实现 strStr()
2. LeetCode 187. 重复的DNA序列  
3. LeetCode 1044. 最长重复子串
4. Codeforces 271D. Good Substrings
5. 洛谷 P3370. 字符串哈希

## 二维字符串哈希

在某些问题中，我们需要在二维网格（矩阵）中快速匹配子矩阵模式。二维字符串哈希将一维哈希的概念扩展到二维，可以高效地判断两个子矩阵是否相同。

### 基本思想

二维哈希使用两个不同的基数：
- `base1`：用于行内的字符哈希
- `base2`：用于列方向的哈希

算法分为两个步骤：
1. 对每一行计算所有长度为B的子串的哈希值
2. 对每一列的哈希值序列计算所有长度为A的子序列的哈希值

### 完整实现

```cpp
#include<bits/stdc++.h>
using namespace std;

class Matrix2DHash {
private:
    // 使用两个不同的基数避免冲突
    static const unsigned long long base1 = (1ULL << 7) - 1;  // 127
    static const unsigned long long base2 = (1ULL << 13) - 1; // 8191
    
    vector<string> grid;
    int M, N;  // 矩阵尺寸
    vector<unsigned long long> pow1, pow2;  // 基数的幂次
    vector<vector<unsigned long long>> rowHash;  // 每行的子串哈希值
    
public:
    Matrix2DHash(const vector<string>& G, int subRows, int subCols) : grid(G) {
        M = G.size();
        N = G[0].size();
        
        // 预计算基数的幂次
        pow1.resize(subCols + 1);
        pow2.resize(subRows + 1);
        pow1[0] = pow2[0] = 1;
        
        for (int i = 1; i <= subCols; i++) {
            pow1[i] = pow1[i - 1] * base1;
        }
        for (int i = 1; i <= subRows; i++) {
            pow2[i] = pow2[i - 1] * base2;
        }
        
        // 计算每行所有长度为subCols的子串哈希值
        rowHash.resize(M, vector<unsigned long long>(N - subCols + 1));
        computeRowHashes(subCols);
    }
    
private:
    void computeRowHashes(int subCols) {
        for (int i = 0; i < M; i++) {
            unsigned long long h = 0;
            
            // 滚动哈希计算该行所有子串
            for (int j = 0; j < N; j++) {
                // 添加当前字符到哈希值
                h = h * base1 + (grid[i][j] - '0' + 1);
                
                // 如果窗口大小超过subCols，移除最左边的字符
                if (j >= subCols) {
                    h -= pow1[subCols] * (grid[i][j - subCols] - '0' + 1);
                }
                
                // 如果窗口大小正好是subCols，保存哈希值
                if (j >= subCols - 1) {
                    rowHash[i][j - subCols + 1] = h;
                }
            }
        }
    }
    
public:
    // 获取所有subRows x subCols子矩阵的哈希值
    unordered_set<unsigned long long> getAllSubmatrixHashes(int subRows, int subCols) {
        unordered_set<unsigned long long> result;
        
        // 对每一列的哈希值序列计算子序列哈希
        for (int j = 0; j <= N - subCols; j++) {
            unsigned long long h = 0;
            
            // 滚动哈希计算该列所有长度为subRows的子序列
            for (int i = 0; i < M; i++) {
                h = h * base2 + rowHash[i][j];
                
                // 如果窗口大小超过subRows，移除最上面的行
                if (i >= subRows) {
                    h -= pow2[subRows] * rowHash[i - subRows][j];
                }
                
                // 如果窗口大小正好是subRows，保存哈希值
                if (i >= subRows - 1) {
                    result.insert(h);
                }
            }
        }
        
        return result;
    }
    
    // 计算给定子矩阵的哈希值
    unsigned long long computePatternHash(const vector<string>& pattern) {
        int A = pattern.size();
        int B = pattern[0].size();
        
        vector<unsigned long long> tempRowHash(A);
        
        // 首先计算每行的哈希值
        for (int i = 0; i < A; i++) {
            unsigned long long h = 0;
            for (int j = 0; j < B; j++) {
                h = h * base1 + (pattern[i][j] - '0' + 1);
            }
            tempRowHash[i] = h;
        }
        
        // 然后计算整个模式的哈希值
        unsigned long long result = 0;
        for (int i = 0; i < A; i++) {
            result = result * base2 + tempRowHash[i];
        }
        
        return result;
    }
};

// 示例：解决二维模式匹配问题
int main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    
    int M, N, A, B;
    cin >> M >> N >> A >> B;
    
    vector<string> grid(M);
    for (int i = 0; i < M; i++) {
        cin >> grid[i];
    }
    
    // 创建二维哈希对象
    Matrix2DHash hasher(grid, A, B);
    
    // 获取所有A×B子矩阵的哈希值
    unordered_set<unsigned long long> allHashes = hasher.getAllSubmatrixHashes(A, B);
    
    int Q;
    cin >> Q;
    
    while (Q--) {
        vector<string> pattern(A);
        for (int i = 0; i < A; i++) {
            cin >> pattern[i];
        }
        
        // 计算查询模式的哈希值
        unsigned long long patternHash = hasher.computePatternHash(pattern);
        
        // 检查是否存在匹配
        if (allHashes.count(patternHash)) {
            cout << "1\n";
        } else {
            cout << "0\n";
        }
    }
    
    return 0;
}
```

### 原始代码详解

让我们分析一下原始代码的关键部分：

```cpp
// 第一步：计算每行的子串哈希值
vector<vector<unsigned long long>> r(M, vector<unsigned long long>(N-B+1));
for(int i = 0; i < M; i++){
    unsigned long long h = 0;
    for(int j = 0; j < N; j++){
        // 滚动哈希：添加新字符
        h = h * base1 + (G[i][j] - '0' + 1);
        
        // 移除窗口最左边的字符
        if(j >= B) h -= p1[B] * (G[i][j-B] - '0' + 1);
        
        // 保存完整窗口的哈希值
        if(j >= B-1) r[i][j-B+1] = h;
    }
}

// 第二步：对每列的哈希值序列计算子序列哈希
unordered_set<unsigned long long> S;
for(int j = 0; j < N-B+1; j++){
    unsigned long long h = 0;
    for(int i = 0; i < M; i++){
        // 滚动哈希：添加新的行哈希值
        h = h * base2 + r[i][j];
        
        // 移除窗口最上面的行
        if(i >= A) h -= p2[A] * r[i-A][j];
        
        // 保存完整窗口的哈希值
        if(i >= A-1) S.insert(h);
    }
}
```

### 算法步骤详解

1. **初始化阶段**：
   - 选择两个互质的基数 `base1` 和 `base2`
   - 预计算基数的幂次：`p1[i] = base1^i`, `p2[i] = base2^i`

2. **行哈希计算**：
   - 对每一行，使用滚动哈希计算所有长度为B的子串哈希值
   - 时间复杂度：O(M × N)

3. **列哈希计算**：
   - 将每列的行哈希值看作一个序列
   - 对每个序列计算所有长度为A的子序列哈希值
   - 时间复杂度：O(M × (N-B+1))

4. **查询处理**：
   - 对查询模式使用相同方法计算哈希值
   - 在预处理的哈希集合中查找
   - 时间复杂度：O(A × B) 每次查询

### 优化技巧

1. **基数选择**：
   ```cpp
   // 选择2的幂减1，计算效率更高
   const unsigned long long base1 = (1ULL << 7) - 1;   // 127
   const unsigned long long base2 = (1ULL << 13) - 1;  // 8191
   ```

2. **字符映射**：
   ```cpp
   // 将字符'0'-'9'映射到1-10，避免0值影响哈希
   h = h * base + (c - '0' + 1);
   ```

3. **内存优化**：
   - 如果只需要判断存在性，可以边计算边查询，不存储所有哈希值
   - 对于大矩阵，考虑使用更紧凑的数据结构

### 时间复杂度分析

- **预处理时间**：O(M × N)
- **查询时间**：O(A × B)
- **空间复杂度**：O(M × N + (M-A+1) × (N-B+1))

### 应用场景

1. **二维模式匹配**：在图像或文本矩阵中查找特定模式
2. **子矩阵去重**：找出矩阵中所有不同的子矩阵
3. **最大重复子矩阵**：找出矩阵中最大的重复子矩阵
4. **矩阵相似度**：快速比较两个矩阵的子区域

这种二维哈希技术在处理大规模矩阵匹配问题时非常高效，是竞赛编程中的重要技巧。